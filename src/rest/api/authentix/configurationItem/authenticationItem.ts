/*
 * This code was generated by
 *  ___ ___   _   ___ _  _    _____ _   _    _  ___   ___      _   ___ ___      ___   _   ___     ___ ___ _  _ ___ ___    _ _____ ___  ___ 
 * | _ \ __| /_\ / __| || |__|_   _/_\ | |  | |/ | \ / / |    /_\ | _ ) __|___ / _ \ /_\ |_ _|__ / __| __| \| | __| _ \  /_\_   _/ _ \| _ \
 * |   / _| / _ \ (__| __ |___|| |/ _ \| |__| ' < \ V /| |__ / _ \| _ \__ \___| (_) / _ \ | |___| (_ | _|| .` | _||   / / _ \| || (_) |   /
 * |_|_\___/_/ \_\___|_||_|    |_/_/ \_\____|_|\_\ |_| |____/_/ \_\___/___/    \___/_/ \_\___|   \___|___|_|\_|___|_|_\/_/ \_\_| \___/|_|_\
 * 
 * Reach Authentix API
 *  Reach Authentix API helps you easily integrate user authentification in your application. The authentification allows to verify that a user is indeed at the origin of a request from your application.  At the moment, the Reach Authentix API supports the following channels:    * SMS      * Email   We are continuously working to add additionnal channels. ## Base URL All endpoints described in this documentation are relative to the following base URL: ``` https://api.reach.talkylabs.com/rest/authentix/v1/ ```  The API is provided over HTTPS protocol to ensure data privacy.  ## API Authentication Requests made to the API must be authenticated. You need to provide the `ApiUser` and `ApiKey` associated with your applet. This information could be found in the settings of the applet. ```curl curl -X GET [BASE_URL]/configurations -H \"ApiUser:[Your_Api_User]\" -H \"ApiKey:[Your_Api_Key]\" ``` ## Reach Authentix API Workflow Three steps are needed in order to authenticate a given user using the Reach Authentix API. ### Step 1: Create an Authentix configuration A configuration is a set of settings used to define and send an authentication code to a user. This includes, for example: ```   - the length of the authentication code,    - the message template,    - and so on... ``` A configuaration could be created via the web application or directly using the Reach Authentix API. This step does not need to be performed every time one wants to use the Reach Authentix API. Indeed, once created, a configuartion could be used to authenticate several users in the future.    ### Step 2: Send an authentication code A configuration is used to send an authentication code via a selected channel to a user. For now, the supported channels are `sms`, and `email`. We are working hard to support additional channels. Newly created authentications will have a status of `awaiting`. ### Step 3: Verify the authentication code This step allows to verify that the code submitted by the user matched the one sent previously. If, there is a match, then the status of the authentication changes from `awaiting` to `passed`. Otherwise, the status remains `awaiting` until either it is verified or it expires. In the latter case, the status becomes `expired`. 
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { inspect, InspectOptions } from "util";
import Page, { ReachResponsePayload } from "../../../../base/Page";
import Response from "../../../../http/response";
import Authentix from "../../Authentix";
const deserialize = require("../../../../base/deserialize");
const serialize = require("../../../../base/serialize");
import { isValidPathParam } from "../../../../base/utility";


/**
 * Information related to the digital payment to authenticate. It is required when `usedForDigitalPayment` is true. It is ignored otherwise.
 */
export class PaymentInfo {
  /**
   * The payee of the financial transaction.
   */
  "payee": string;
  /**
   * the amount of the transaction.
   */
  "amount": number;
  /**
   * The currency of the transaction.
   */
  "currency": string;
}


export class TrialQuickInfo {
  /**
   * The date and time in GMT that the trial was created. 
   */
  "dateCreated"?: Date;
  /**
   * the trial ID
   */
  "trialId"?: string;
  /**
   * The channel used.
   */
  "channel"?: string;
}




/**
 * Options to pass to update a AuthenticationItemInstance
 */
export interface AuthenticationItemContextUpdateOptions {
  /** The new status of the authentication. */
  "status": string;
}
/**
 * Options to pass to each
 */
export interface AuthenticationItemListInstanceEachOptions {
  /** Maximum number of records to return per call. */
  "pageSize"?: number;
  /** Function to process each record. If this and a positional callback are passed, this one will be used */
  callback?: (item: AuthenticationItemInstance, done: (err?: Error) => void) => void;
  /** Function to be called upon completion of streaming */
  done?: Function;
  /** Upper limit for the number of records to return. each() guarantees never to return more than limit. Default is no limit */
  limit?: number;
}

/**
 * Options to pass to list
 */
export interface AuthenticationItemListInstanceOptions {
  /** Maximum number of records to return per call. */
  "pageSize"?: number;
  /** Upper limit for the number of records to return. list() guarantees never to return more than limit. Default is no limit */
  limit?: number;
}

/**
 * Options to pass to page
 */
export interface AuthenticationItemListInstancePageOptions {
  /** Maximum number of records to return per call. */
  "pageSize"?: number;
  /** Page Number, this value is simply for client state */
  pageNumber?: number;
}


/**
 * Options to pass to start a AuthenticationItemInstance
 */
export interface AuthenticationItemListInstanceStartOptions {
  /** The phone number or email where to send the authentication code. Phone numbers must be in E.164 format. */
  "dest": string;
  /** The channel by which the authentication code is sent. */
  "channel": string;
  /** a service name overwriting the one defined in the configuration. */
  "serviceName"?: string;
  /** the pre-generated code to be sent. Its length should be between 4 and 10 inclusive. */
  "customCode"?: string;
  /** Information related to the digital payment to authenticate. It is required when `usedForDigitalPayment` is true. It is ignored otherwise. It is a stringfied JSON map where keys are `payee`, `amount`, and `currency` and the associated values are respectively the payee, the amount, and the currency of a financial transaction.  */
  "paymentInfo"?: string;
  /** This is the ID of the message template to use for sending the authenetication code. It could be an sms or email template depending on the channel being used. It overwirites the template ID defined in the configuration if any.  */
  "templateId"?: string;
  /** A stringfied JSON map where keys are message template parameters and the values are the parameter values to be used when sending the authentication code. It may also be used to provide additional parameters for sending email based authentications such as the email used for sending the code. */
  "templateDataMap"?: string;
}

export interface AuthenticationItemContext {

  /**
   * Fetch a AuthenticationItemInstance
   *
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed AuthenticationItemInstance
   */
  fetch(callback?: (error: Error | null, item?: AuthenticationItemInstance) => any): Promise<AuthenticationItemInstance>

  /**
   * Update a AuthenticationItemInstance
   *
   * @param params - Parameter for request
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed AuthenticationItemInstance
   */
  update(params: AuthenticationItemContextUpdateOptions, callback?: (error: Error | null, item?: AuthenticationItemInstance) => any): Promise<AuthenticationItemInstance>;



  /**
   * Provide a user-friendly representation
   */
  toJSON(): any;
  [inspect.custom](_depth: any, options: InspectOptions): any;
}

export interface AuthenticationItemContextSolution {
  "configurationId": string;
  "authenticationId": string;
}

export class AuthenticationItemContextImpl implements AuthenticationItemContext {
  protected _solution: AuthenticationItemContextSolution;
  protected _uri: string;


  constructor(protected _version: Authentix, configurationId: string, authenticationId: string) {
    if (!isValidPathParam(configurationId)) {
      throw new Error('Parameter \'configurationId\' is not valid.');
    }

    if (!isValidPathParam(authenticationId)) {
      throw new Error('Parameter \'authenticationId\' is not valid.');
    }

    this._solution = { configurationId, authenticationId,  };
    this._uri = `/authentix/v1/configurations/${configurationId}/authentications/${authenticationId}`;
  }

  fetch(callback?: (error: Error | null, item?: AuthenticationItemInstance) => any): Promise<AuthenticationItemInstance> {
  
    const instance = this;
    let operationVersion = instance._version,
        operationPromise = operationVersion.fetch({ uri: instance._uri, method: "get" });
    
    operationPromise = operationPromise.then(payload => new AuthenticationItemInstance(operationVersion, payload, instance._solution.configurationId, instance._solution.authenticationId));
    

    operationPromise = instance._version.setPromiseCallback(operationPromise,callback);
    return operationPromise;


  }

  update(params: AuthenticationItemContextUpdateOptions, callback?: (error: Error | null, item?: AuthenticationItemInstance) => any): Promise<AuthenticationItemInstance> {
      if (params === null || params === undefined) {
      throw new Error('Required parameter "params" missing.');
    }

    if (params["status"] === null || params["status"] === undefined) {
      throw new Error('Required parameter "params[\'status\']" missing.');
    }

    let data: any = {};

    
        
    data["status"] = params["status"];


    const headers: any = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded"

    const instance = this;
    let operationVersion = instance._version,
        operationPromise = operationVersion.update({ uri: instance._uri, method: "post", data, headers });
    
    operationPromise = operationPromise.then(payload => new AuthenticationItemInstance(operationVersion, payload, instance._solution.configurationId, instance._solution.authenticationId));
    

    operationPromise = instance._version.setPromiseCallback(operationPromise,callback);
    return operationPromise;


  }

  /**
   * Provide a user-friendly representation
   *
   * @returns Object
   */
  toJSON() {
    return this._solution;
  }

  [inspect.custom](_depth: any, options: InspectOptions) {
    return inspect(this.toJSON(), options);
  }
}


interface AuthenticationItemPayload extends ReachResponsePayload {
    authentications: AuthenticationItemResource[];
}

interface AuthenticationItemResource {
  appletId: string;
  apiVersion: string;
  configurationId: string;
  authenticationId: string;
  status: string;
  dest: string;
  channel: string;
  expiryTime: number;
  maxTrials: number;
  maxControls: number;
  paymentInfo: PaymentInfo;
  trials: Array<TrialQuickInfo>;
  dateCreated: Date;
  dateUpdated: Date;
}

export class AuthenticationItemInstance {
  protected _solution: AuthenticationItemContextSolution;
  protected _context?: AuthenticationItemContext;

  constructor(protected _version: Authentix, payload: AuthenticationItemResource, configurationId: string, authenticationId?: string) {
    this.appletId = (payload.appletId);
    this.apiVersion = (payload.apiVersion);
    this.configurationId = (payload.configurationId);
    this.authenticationId = (payload.authenticationId);
    this.status = (payload.status);
    this.dest = (payload.dest);
    this.channel = (payload.channel);
    this.expiryTime = deserialize.integer(payload.expiryTime);
    this.maxTrials = deserialize.integer(payload.maxTrials);
    this.maxControls = deserialize.integer(payload.maxControls);
    this.paymentInfo = (payload.paymentInfo);
    this.trials = (payload.trials);
    this.dateCreated = deserialize.iso8601DateTime(payload.dateCreated);
    this.dateUpdated = deserialize.iso8601DateTime(payload.dateUpdated);

    this._solution = { configurationId, authenticationId: authenticationId || this.authenticationId,  };
  }

  /**
   * The identifier of the applet.
   */
  appletId: string;
  /**
   * The API version.
   */
  apiVersion: string;
  /**
   * The identifier of the configuration.
   */
  configurationId: string;
  /**
   * The identifier of the authentication.
   */
  authenticationId: string;
  /**
   * The status of the authentication.
   */
  status: string;
  /**
   * The destination of the authentication code. Phone numbers must be in E.164 format.
   */
  dest: string;
  /**
   * The channel used.
   */
  channel: string;
  /**
   * An expiry time in minutes. 
   */
  expiryTime: number;
  /**
   * The maximum number of trials. 
   */
  maxTrials: number;
  /**
   * The maximum number of code controls. 
   */
  maxControls: number;
  paymentInfo: PaymentInfo;
  /**
   * An array of authentication trials containing channel-specific information about each trial.
   */
  trials: Array<TrialQuickInfo>;
  /**
   * The date and time in GMT that the authentication was created. 
   */
  dateCreated: Date;
  /**
   * The date and time in GMT that the authentication was last updated. 
   */
  dateUpdated: Date;

  private get _proxy(): AuthenticationItemContext {
    this._context = this._context || new AuthenticationItemContextImpl(this._version, this._solution.configurationId, this._solution.authenticationId);
    return this._context;
  }

  /**
   * Fetch a AuthenticationItemInstance
   *
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed AuthenticationItemInstance
   */
  fetch(callback?: (error: Error | null, item?: AuthenticationItemInstance) => any): Promise<AuthenticationItemInstance>

    {
    return this._proxy.fetch(callback);
  }

  /**
   * Update a AuthenticationItemInstance
   *
   * @param params - Parameter for request
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed AuthenticationItemInstance
   */
  update(params: AuthenticationItemContextUpdateOptions, callback?: (error: Error | null, item?: AuthenticationItemInstance) => any): Promise<AuthenticationItemInstance>;

    update(params?: any, callback?: (error: Error | null, item?: AuthenticationItemInstance) => any): Promise<AuthenticationItemInstance>
    {
    return this._proxy.update(params, callback);
  }

  /**
   * Provide a user-friendly representation
   *
   * @returns Object
   */
  toJSON() {
    return {
      appletId: this.appletId,
      apiVersion: this.apiVersion,
      configurationId: this.configurationId,
      authenticationId: this.authenticationId,
      status: this.status,
      dest: this.dest,
      channel: this.channel,
      expiryTime: this.expiryTime,
      maxTrials: this.maxTrials,
      maxControls: this.maxControls,
      paymentInfo: this.paymentInfo,
      trials: this.trials,
      dateCreated: this.dateCreated,
      dateUpdated: this.dateUpdated,
    }
  }

  [inspect.custom](_depth: any, options: InspectOptions) {
    return inspect(this.toJSON(), options);
  }
}


export interface AuthenticationItemSolution {
  configurationId: string;
}

export interface AuthenticationItemListInstance {
  _version: Authentix;
  _solution: AuthenticationItemSolution;
  _uri: string;
  

  (authenticationId: string, ): AuthenticationItemContext;
  get(authenticationId: string, ): AuthenticationItemContext;







  /**
   * Streams AuthenticationItemInstance records from the API.
   *
   * This operation lazily loads records as efficiently as possible until the limit
   * is reached.
   *
   * The results are passed into the callback function, so this operation is memory
   * efficient.
   *
   * If a function is passed as the first argument, it will be used as the callback
   * function.
   *
   * @param { AuthenticationItemListInstanceEachOptions } [params] - Options for request
   * @param { function } [callback] - Function to process each record
   */
  each(callback?: (item: AuthenticationItemInstance, done: (err?: Error) => void) => void): void;
  each(params: AuthenticationItemListInstanceEachOptions, callback?: (item: AuthenticationItemInstance, done: (err?: Error) => void) => void): void;
  /**
   * Retrieve a single target page of AuthenticationItemInstance records from the API.
   *
   * The request is executed immediately.
   *
   * @param { string } [targetUrl] - API-generated URL for the requested results page
   * @param { function } [callback] - Callback to handle list of records
   */
  getPage(targetUrl: string, callback?: (error: Error | null, items: AuthenticationItemPage) => any): Promise<AuthenticationItemPage>;
  /**
   * Lists AuthenticationItemInstance records from the API as a list.
   *
   * If a function is passed as the first argument, it will be used as the callback
   * function.
   *
   * @param { AuthenticationItemListInstanceOptions } [params] - Options for request
   * @param { function } [callback] - Callback to handle list of records
   */
  list(callback?: (error: Error | null, items: AuthenticationItemInstance[]) => any): Promise<AuthenticationItemInstance[]>;
  list(params: AuthenticationItemListInstanceOptions, callback?: (error: Error | null, items: AuthenticationItemInstance[]) => any): Promise<AuthenticationItemInstance[]>;
  /**
   * Retrieve a single page of AuthenticationItemInstance records from the API.
   *
   * The request is executed immediately.
   *
   * If a function is passed as the first argument, it will be used as the callback
   * function.
   *
   * @param { AuthenticationItemListInstancePageOptions } [params] - Options for request
   * @param { function } [callback] - Callback to handle list of records
   */
  page(callback?: (error: Error | null, items: AuthenticationItemPage) => any): Promise<AuthenticationItemPage>;
  page(params: AuthenticationItemListInstancePageOptions, callback?: (error: Error | null, items: AuthenticationItemPage) => any): Promise<AuthenticationItemPage>;

  /**
   * Start a AuthenticationItemInstance
   *
   * @param params - Parameter for request
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed AuthenticationItemInstance
   */
  start(params: AuthenticationItemListInstanceStartOptions, callback?: (error: Error | null, item?: AuthenticationItemInstance) => any): Promise<AuthenticationItemInstance>;


  /**
   * Provide a user-friendly representation
   */
  toJSON(): any;
  [inspect.custom](_depth: any, options: InspectOptions): any;
}

export function AuthenticationItemListInstance(version: Authentix, configurationId: string): AuthenticationItemListInstance {
  if (!isValidPathParam(configurationId)) {
    throw new Error('Parameter \'configurationId\' is not valid.');
  }

  const instance = ((authenticationId, ) => instance.get(authenticationId, )) as AuthenticationItemListInstance;

  instance.get = function get(authenticationId, ): AuthenticationItemContext {
    return new AuthenticationItemContextImpl(version, configurationId, authenticationId);
  }

  instance._version = version;
  instance._solution = { configurationId,  };
  instance._uri = `/authentix/v1/configurations/${configurationId}/authentications`;

  instance.page = function page(params?: AuthenticationItemListInstancePageOptions | ((error: Error | null, items: AuthenticationItemPage) => any), callback?: (error: Error | null, items: AuthenticationItemPage) => any): Promise<AuthenticationItemPage> {
    if (params instanceof Function) {
      callback = params;
      params = {};
    } else {
      params = params || {};
    }

    let data: any = {};

        if (params["pageSize"] !== undefined)
    data["pageSize"] = params["pageSize"];

    
    if (params.pageNumber !== undefined) data["page"] = params.pageNumber;

    const headers: any = {};

    let operationVersion = version,
        operationPromise = operationVersion.page({ uri: instance._uri, method: "get", params: data, headers });
    
    let basePageUrl = operationVersion.urlWithoutPaginationInfo(operationVersion.absoluteUrl(instance._uri), data);
    operationPromise = operationPromise.then(payload => new AuthenticationItemPage(basePageUrl, operationVersion, payload, instance._solution));

    operationPromise = instance._version.setPromiseCallback(operationPromise,callback);
    return operationPromise;

  }
  instance.each = instance._version.each;
  instance.list = instance._version.list;

  instance.getPage = function getPage(targetUrl: string, callback?: (error: Error | null, items: AuthenticationItemPage) => any): Promise<AuthenticationItemPage> {
    const operationPromise = instance._version._domain.reach.request({method: "get", uri: targetUrl});

    let basePageUrl = instance._version.urlWithoutPaginationInfo(targetUrl);
    let pagePromise = operationPromise.then(payload => new AuthenticationItemPage(basePageUrl, instance._version, payload, instance._solution));
    pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
    return pagePromise;
  }


  instance.start = function start(params: AuthenticationItemListInstanceStartOptions, callback?: (error: Error | null, items: AuthenticationItemInstance) => any): Promise<AuthenticationItemInstance> {
    if (params === null || params === undefined) {
      throw new Error('Required parameter "params" missing.');
    }

    if (params["dest"] === null || params["dest"] === undefined) {
      throw new Error('Required parameter "params[\'dest\']" missing.');
    }

    if (params["channel"] === null || params["channel"] === undefined) {
      throw new Error('Required parameter "params[\'channel\']" missing.');
    }

    let data: any = {};

    
        
    data["dest"] = params["dest"];
    
    data["channel"] = params["channel"];
    if (params["serviceName"] !== undefined)
    data["serviceName"] = params["serviceName"];
    if (params["customCode"] !== undefined)
    data["customCode"] = params["customCode"];
    if (params["paymentInfo"] !== undefined)
    data["paymentInfo"] = params["paymentInfo"];
    if (params["templateId"] !== undefined)
    data["templateId"] = params["templateId"];
    if (params["templateDataMap"] !== undefined)
    data["templateDataMap"] = params["templateDataMap"];


    const headers: any = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded"

    let operationVersion = version,
        operationPromise = operationVersion.start({ uri: instance._uri, method: "post", data, headers });
    
    operationPromise = operationPromise.then(payload => new AuthenticationItemInstance(operationVersion, payload, instance._solution.configurationId));
    

    operationPromise = instance._version.setPromiseCallback(operationPromise,callback);
    return operationPromise;


    }

  instance.toJSON = function toJSON() {
    return instance._solution;
  }

  instance[inspect.custom] = function inspectImpl(_depth: any, options: InspectOptions) {
    return inspect(instance.toJSON(), options);
  }

  return instance;
}

export class AuthenticationItemPage extends Page<Authentix, AuthenticationItemPayload, AuthenticationItemResource, AuthenticationItemInstance> {
/**
* Initialize the AuthenticationItemPage
*
* @param url - the url of the resource without pagination info
* @param version - Version of the resource
* @param response - Response from the API
* @param solution - Path solution
*/
constructor(url: string, version: Authentix, response: Response<string>, solution: AuthenticationItemSolution) {
    super(url, version, response, solution);
    }

    /**
    * Build an instance of AuthenticationItemInstance
    *
    * @param payload - Payload response from the API
    */
    getInstance(payload: AuthenticationItemResource): AuthenticationItemInstance {
    return new AuthenticationItemInstance(
    this._version,
    payload,
        this._solution.configurationId,
    );
    }

    [inspect.custom](depth: any, options: InspectOptions) {
    return inspect(this.toJSON(), options);
    }
    }

