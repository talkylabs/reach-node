/*
 * This code was generated by
 *  ___ ___   _   ___ _  _    _____ _   _    _  ___   ___      _   ___ ___      ___   _   ___     ___ ___ _  _ ___ ___    _ _____ ___  ___ 
 * | _ \ __| /_\ / __| || |__|_   _/_\ | |  | |/ | \ / / |    /_\ | _ ) __|___ / _ \ /_\ |_ _|__ / __| __| \| | __| _ \  /_\_   _/ _ \| _ \
 * |   / _| / _ \ (__| __ |___|| |/ _ \| |__| ' < \ V /| |__ / _ \| _ \__ \___| (_) / _ \ | |___| (_ | _|| .` | _||   / / _ \| || (_) |   /
 * |_|_\___/_/ \_\___|_||_|    |_/_/ \_\____|_|\_\ |_| |____/_/ \_\___/___/    \___/_/ \_\___|   \___|___|_|\_|___|_|_\/_/ \_\_| \___/|_|_\
 * 
 * Reach Authentix API
 *  Reach Authentix API helps you easily integrate user authentification in your application. The authentification allows to verify that a user is indeed at the origin of a request from your application.  At the moment, the Reach Authentix API supports the following channels:    * SMS      * Email   We are continuously working to add additionnal channels. ## Base URL All endpoints described in this documentation are relative to the following base URL: ``` https://api.reach.talkylabs.com/rest/authentix/v1/ ```  The API is provided over HTTPS protocol to ensure data privacy.  ## API Authentication Requests made to the API must be authenticated. You need to provide the `ApiUser` and `ApiKey` associated with your applet. This information could be found in the settings of the applet. ```curl curl -X GET [BASE_URL]/configurations -H \"ApiUser:[Your_Api_User]\" -H \"ApiKey:[Your_Api_Key]\" ``` ## Reach Authentix API Workflow Three steps are needed in order to authenticate a given user using the Reach Authentix API. ### Step 1: Create an Authentix configuration A configuration is a set of settings used to define and send an authentication code to a user. This includes, for example: ```   - the length of the authentication code,    - the message template,    - and so on... ``` A configuaration could be created via the web application or directly using the Reach Authentix API. This step does not need to be performed every time one wants to use the Reach Authentix API. Indeed, once created, a configuartion could be used to authenticate several users in the future.    ### Step 2: Send an authentication code A configuration is used to send an authentication code via a selected channel to a user. For now, the supported channels are `sms`, and `email`. We are working hard to support additional channels. Newly created authentications will have a status of `awaiting`. ### Step 3: Verify the authentication code This step allows to verify that the code submitted by the user matched the one sent previously. If, there is a match, then the status of the authentication changes from `awaiting` to `passed`. Otherwise, the status remains `awaiting` until either it is verified or it expires. In the latter case, the status becomes `expired`. 
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { inspect, InspectOptions } from "util";
import Page, { ReachResponsePayload } from "../../../base/Page";
import Response from "../../../http/response";
import Authentix from "../Authentix";
const deserialize = require("../../../base/deserialize");
const serialize = require("../../../base/serialize");
import { isValidPathParam } from "../../../base/utility";
import { AuthenticationControlItemListInstance } from "./configurationItem/authenticationControlItem";
import { AuthenticationItemListInstance } from "./configurationItem/authenticationItem";





/**
 * Options to pass to update a ConfigurationItemInstance
 */
export interface ConfigurationItemContextUpdateOptions {
  /** The name of the authentication service attached to this configuration. It can be up to 40 characters long. */
  "serviceName"?: string;
  /** The length of the code to be generated. It must be a value between 4 and 10, inclusive. */
  "codeLength"?: number;
  /** A flag indicating if the configuration should allow sending custom and non-generated code. */
  "allowCustomCode"?: boolean;
  /** A flag indicating if the configuration is used to authenticate digital payments. In such a case, additional information such as the amount and the payee of the financial transaction should be sent to when starting the authentication. */
  "usedForDigitalPayment"?: boolean;
  /** It represents how long, in minutes, an authentication process will remained in the `awaiting` status before moving to `expired` in the case no valid matching is performed in between. It must be any value between 1 and 1440 which represents 24 hours. */
  "defaultExpiryTime"?: number;
  /** It represents the maximum number of trials per authentication.  */
  "defaultMaxTrials"?: number;
  /** It represents the maximum number of code controls per authentication. It must be between 1 and 6 inclusive.  */
  "defaultMaxControls"?: number;
  /** This is the ID of the SMTP settings used by this configuration. It is mandatory for sending authentication codes via email. */
  "smtpSettingId"?: string;
  /** This is the ID of the default email template to use for sending authenetication codes via email.  */
  "emailTemplateId"?: string;
  /** This is the ID of the default sms template to use for sending authenetication codes via sms.  */
  "smsTemplateId"?: string;
}

/**
 * Options to pass to create a ConfigurationItemInstance
 */
export interface ConfigurationItemListInstanceCreateOptions {
  /** The name of the authentication service attached to this configuration. It can be up to 40 characters long. */
  "serviceName": string;
  /** The length of the code to be generated. It must be a value between 4 and 10, inclusive. If not specified, the default value is 5. */
  "codeLength"?: number;
  /** A flag indicating if the configuration should allow sending custom and non-generated code. */
  "allowCustomCode"?: boolean;
  /** A flag indicating if the configuration is used to authenticate digital payments. In such a case, additional information such as the amount and the payee of the financial transaction should be sent to when starting the authentication. */
  "usedForDigitalPayment"?: boolean;
  /** It represents how long, in minutes, an authentication process will remained in the `awaiting` status before moving to `expired` in the case no valid matching is performed in between.   It also means that the code sent for the autentication remains the same during its validity period until the autentication is successful. In other words, if another authentication request is asked within that period, the same code will be sent.  If not specified, the default value is 15 minutes. It must be any value between 1 and 1440 which represents 24 hours.  */
  "defaultExpiryTime"?: number;
  /** It represents the maximum number of trials per authentication. The default value is 5.  */
  "defaultMaxTrials"?: number;
  /** It represents the maximum number of code controls per authentication. It must be between 1 and 6 inclusive. The default value is 3.  */
  "defaultMaxControls"?: number;
  /** This is the ID of the SMTP settings used by this configuration. It is mandatory to provide this parameter in order to send the authentication code via email. An SMTPSetting can be created via the web application in an easy way. */
  "smtpSettingId"?: string;
  /** This is the ID of the default email template to use for sending authenetication codes via email. If not provided, the message used will be:   ```    ${SERVICE_NAME}: your authentication code is ${CODE}.  ```    */
  "emailTemplateId"?: string;
  /** This is the ID of the default sms template to use for sending authenetication codes via sms. If not provided, the message used will be:   ```    ${SERVICE_NAME}: your authentication code is ${CODE}.  ```  */
  "smsTemplateId"?: string;
}
/**
 * Options to pass to each
 */
export interface ConfigurationItemListInstanceEachOptions {
  /** Maximum number of records to return per call. */
  "pageSize"?: number;
  /** Function to process each record. If this and a positional callback are passed, this one will be used */
  callback?: (item: ConfigurationItemInstance, done: (err?: Error) => void) => void;
  /** Function to be called upon completion of streaming */
  done?: Function;
  /** Upper limit for the number of records to return. each() guarantees never to return more than limit. Default is no limit */
  limit?: number;
}

/**
 * Options to pass to list
 */
export interface ConfigurationItemListInstanceOptions {
  /** Maximum number of records to return per call. */
  "pageSize"?: number;
  /** Upper limit for the number of records to return. list() guarantees never to return more than limit. Default is no limit */
  limit?: number;
}

/**
 * Options to pass to page
 */
export interface ConfigurationItemListInstancePageOptions {
  /** Maximum number of records to return per call. */
  "pageSize"?: number;
  /** Page Number, this value is simply for client state */
  pageNumber?: number;
}


export interface ConfigurationItemContext {
  authenticationControlItems: AuthenticationControlItemListInstance;
  authenticationItems: AuthenticationItemListInstance;

  /**
   * Remove a ConfigurationItemInstance
   *
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed boolean
   */
  remove(callback?: (error: Error | null, item?: boolean) => any): Promise<boolean>

  /**
   * Fetch a ConfigurationItemInstance
   *
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed ConfigurationItemInstance
   */
  fetch(callback?: (error: Error | null, item?: ConfigurationItemInstance) => any): Promise<ConfigurationItemInstance>

  /**
   * Update a ConfigurationItemInstance
   *
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed ConfigurationItemInstance
   */
  update(callback?: (error: Error | null, item?: ConfigurationItemInstance) => any): Promise<ConfigurationItemInstance>;
  /**
   * Update a ConfigurationItemInstance
   *
   * @param params - Parameter for request
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed ConfigurationItemInstance
   */
  update(params: ConfigurationItemContextUpdateOptions, callback?: (error: Error | null, item?: ConfigurationItemInstance) => any): Promise<ConfigurationItemInstance>;



  /**
   * Provide a user-friendly representation
   */
  toJSON(): any;
  [inspect.custom](_depth: any, options: InspectOptions): any;
}

export interface ConfigurationItemContextSolution {
  "configurationId": string;
}

export class ConfigurationItemContextImpl implements ConfigurationItemContext {
  protected _solution: ConfigurationItemContextSolution;
  protected _uri: string;

  protected _authenticationControlItems?: AuthenticationControlItemListInstance;
  protected _authenticationItems?: AuthenticationItemListInstance;

  constructor(protected _version: Authentix, configurationId: string) {
    if (!isValidPathParam(configurationId)) {
      throw new Error('Parameter \'configurationId\' is not valid.');
    }

    this._solution = { configurationId,  };
    this._uri = `/authentix/v1/configurations/${configurationId}`;
  }

  get authenticationControlItems(): AuthenticationControlItemListInstance {
    this._authenticationControlItems = this._authenticationControlItems || AuthenticationControlItemListInstance(this._version, this._solution.configurationId);
    return this._authenticationControlItems;
  }

  get authenticationItems(): AuthenticationItemListInstance {
    this._authenticationItems = this._authenticationItems || AuthenticationItemListInstance(this._version, this._solution.configurationId);
    return this._authenticationItems;
  }

  remove(callback?: (error: Error | null, item?: boolean) => any): Promise<boolean> {
  
    const instance = this;
    let operationVersion = instance._version,
        operationPromise = operationVersion.remove({ uri: instance._uri, method: "delete" });
    

    operationPromise = instance._version.setPromiseCallback(operationPromise,callback);
    return operationPromise;


  }

  fetch(callback?: (error: Error | null, item?: ConfigurationItemInstance) => any): Promise<ConfigurationItemInstance> {
  
    const instance = this;
    let operationVersion = instance._version,
        operationPromise = operationVersion.fetch({ uri: instance._uri, method: "get" });
    
    operationPromise = operationPromise.then(payload => new ConfigurationItemInstance(operationVersion, payload, instance._solution.configurationId));
    

    operationPromise = instance._version.setPromiseCallback(operationPromise,callback);
    return operationPromise;


  }

  update(params?: ConfigurationItemContextUpdateOptions | ((error: Error | null, item?: ConfigurationItemInstance) => any), callback?: (error: Error | null, item?: ConfigurationItemInstance) => any): Promise<ConfigurationItemInstance> {
      if (params instanceof Function) {
      callback = params;
      params = {};
    } else {
      params = params || {};
    }

    let data: any = {};

    
        if (params["serviceName"] !== undefined)
    data["serviceName"] = params["serviceName"];
    if (params["codeLength"] !== undefined)
    data["codeLength"] = params["codeLength"];
    if (params["allowCustomCode"] !== undefined)
    data["allowCustomCode"] = serialize.bool(params["allowCustomCode"]);
    if (params["usedForDigitalPayment"] !== undefined)
    data["usedForDigitalPayment"] = serialize.bool(params["usedForDigitalPayment"]);
    if (params["defaultExpiryTime"] !== undefined)
    data["defaultExpiryTime"] = params["defaultExpiryTime"];
    if (params["defaultMaxTrials"] !== undefined)
    data["defaultMaxTrials"] = params["defaultMaxTrials"];
    if (params["defaultMaxControls"] !== undefined)
    data["defaultMaxControls"] = params["defaultMaxControls"];
    if (params["smtpSettingId"] !== undefined)
    data["smtpSettingId"] = params["smtpSettingId"];
    if (params["emailTemplateId"] !== undefined)
    data["emailTemplateId"] = params["emailTemplateId"];
    if (params["smsTemplateId"] !== undefined)
    data["smsTemplateId"] = params["smsTemplateId"];


    const headers: any = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded"

    const instance = this;
    let operationVersion = instance._version,
        operationPromise = operationVersion.update({ uri: instance._uri, method: "post", data, headers });
    
    operationPromise = operationPromise.then(payload => new ConfigurationItemInstance(operationVersion, payload, instance._solution.configurationId));
    

    operationPromise = instance._version.setPromiseCallback(operationPromise,callback);
    return operationPromise;


  }

  /**
   * Provide a user-friendly representation
   *
   * @returns Object
   */
  toJSON() {
    return this._solution;
  }

  [inspect.custom](_depth: any, options: InspectOptions) {
    return inspect(this.toJSON(), options);
  }
}


interface ConfigurationItemPayload extends ReachResponsePayload {
    configurations: ConfigurationItemResource[];
}

interface ConfigurationItemResource {
  appletId: string;
  apiVersion: string;
  configurationId: string;
  serviceName: string;
  codeLength: number;
  allowCustomCode: boolean;
  usedForDigitalPayment: boolean;
  defaultExpiryTime: number;
  defaultMaxTrials: number;
  defaultMaxControls: number;
  smtpSettingId: string;
  emailTemplateId: string;
  smsTemplateId: string;
  dateCreated: Date;
  dateUpdated: Date;
}

export class ConfigurationItemInstance {
  protected _solution: ConfigurationItemContextSolution;
  protected _context?: ConfigurationItemContext;

  constructor(protected _version: Authentix, payload: ConfigurationItemResource, configurationId?: string) {
    this.appletId = (payload.appletId);
    this.apiVersion = (payload.apiVersion);
    this.configurationId = (payload.configurationId);
    this.serviceName = (payload.serviceName);
    this.codeLength = deserialize.integer(payload.codeLength);
    this.allowCustomCode = (payload.allowCustomCode);
    this.usedForDigitalPayment = (payload.usedForDigitalPayment);
    this.defaultExpiryTime = deserialize.integer(payload.defaultExpiryTime);
    this.defaultMaxTrials = deserialize.integer(payload.defaultMaxTrials);
    this.defaultMaxControls = deserialize.integer(payload.defaultMaxControls);
    this.smtpSettingId = (payload.smtpSettingId);
    this.emailTemplateId = (payload.emailTemplateId);
    this.smsTemplateId = (payload.smsTemplateId);
    this.dateCreated = deserialize.iso8601DateTime(payload.dateCreated);
    this.dateUpdated = deserialize.iso8601DateTime(payload.dateUpdated);

    this._solution = { configurationId: configurationId || this.configurationId,  };
  }

  /**
   * The identifier of the applet creating the configuration.
   */
  appletId: string;
  /**
   * The API version used to create the configuration.
   */
  apiVersion: string;
  /**
   * The identifier of the configuration.
   */
  configurationId: string;
  /**
   * The name of the authentication service.
   */
  serviceName: string;
  /**
   * The length of the code to be generated.
   */
  codeLength: number;
  /**
   * A flag indicating if the configuration allows sending custom and non-generated code.
   */
  allowCustomCode: boolean;
  /**
   * A flag indicating if the configuration is used to authenticate digital payments.
   */
  usedForDigitalPayment: boolean;
  /**
   * the default expiry time of the authentication code.
   */
  defaultExpiryTime: number;
  /**
   * the default maximum number of trials per authentication.
   */
  defaultMaxTrials: number;
  /**
   * the default maximum number of code controls per authentication.
   */
  defaultMaxControls: number;
  /**
   * The ID of the SMTP settings used by the configuration.
   */
  smtpSettingId: string;
  /**
   * The default email template ID used by this configuration. 
   */
  emailTemplateId: string;
  /**
   * The default sms template ID used by this configuration. 
   */
  smsTemplateId: string;
  /**
   * The date and time in GMT that the configuration was created. 
   */
  dateCreated: Date;
  /**
   * The date and time in GMT that the configuration was last updated. 
   */
  dateUpdated: Date;

  private get _proxy(): ConfigurationItemContext {
    this._context = this._context || new ConfigurationItemContextImpl(this._version, this._solution.configurationId);
    return this._context;
  }

  /**
   * Remove a ConfigurationItemInstance
   *
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed boolean
   */
  remove(callback?: (error: Error | null, item?: boolean) => any): Promise<boolean>

    {
    return this._proxy.remove(callback);
  }

  /**
   * Fetch a ConfigurationItemInstance
   *
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed ConfigurationItemInstance
   */
  fetch(callback?: (error: Error | null, item?: ConfigurationItemInstance) => any): Promise<ConfigurationItemInstance>

    {
    return this._proxy.fetch(callback);
  }

  /**
   * Update a ConfigurationItemInstance
   *
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed ConfigurationItemInstance
   */
  update(callback?: (error: Error | null, item?: ConfigurationItemInstance) => any): Promise<ConfigurationItemInstance>;
  /**
   * Update a ConfigurationItemInstance
   *
   * @param params - Parameter for request
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed ConfigurationItemInstance
   */
  update(params: ConfigurationItemContextUpdateOptions, callback?: (error: Error | null, item?: ConfigurationItemInstance) => any): Promise<ConfigurationItemInstance>;

    update(params?: any, callback?: (error: Error | null, item?: ConfigurationItemInstance) => any): Promise<ConfigurationItemInstance>
    {
    return this._proxy.update(params, callback);
  }

  /**
   * Access the authenticationControlItems.
   */
  authenticationControlItems(): AuthenticationControlItemListInstance {
    return this._proxy.authenticationControlItems;
  }

  /**
   * Access the authenticationItems.
   */
  authenticationItems(): AuthenticationItemListInstance {
    return this._proxy.authenticationItems;
  }

  /**
   * Provide a user-friendly representation
   *
   * @returns Object
   */
  toJSON() {
    return {
      appletId: this.appletId,
      apiVersion: this.apiVersion,
      configurationId: this.configurationId,
      serviceName: this.serviceName,
      codeLength: this.codeLength,
      allowCustomCode: this.allowCustomCode,
      usedForDigitalPayment: this.usedForDigitalPayment,
      defaultExpiryTime: this.defaultExpiryTime,
      defaultMaxTrials: this.defaultMaxTrials,
      defaultMaxControls: this.defaultMaxControls,
      smtpSettingId: this.smtpSettingId,
      emailTemplateId: this.emailTemplateId,
      smsTemplateId: this.smsTemplateId,
      dateCreated: this.dateCreated,
      dateUpdated: this.dateUpdated,
    }
  }

  [inspect.custom](_depth: any, options: InspectOptions) {
    return inspect(this.toJSON(), options);
  }
}


export interface ConfigurationItemSolution {
}

export interface ConfigurationItemListInstance {
  _version: Authentix;
  _solution: ConfigurationItemSolution;
  _uri: string;
  

  (configurationId: string, ): ConfigurationItemContext;
  get(configurationId: string, ): ConfigurationItemContext;








  /**
   * Create a ConfigurationItemInstance
   *
   * @param params - Parameter for request
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed ConfigurationItemInstance
   */
  create(params: ConfigurationItemListInstanceCreateOptions, callback?: (error: Error | null, item?: ConfigurationItemInstance) => any): Promise<ConfigurationItemInstance>;



  /**
   * Streams ConfigurationItemInstance records from the API.
   *
   * This operation lazily loads records as efficiently as possible until the limit
   * is reached.
   *
   * The results are passed into the callback function, so this operation is memory
   * efficient.
   *
   * If a function is passed as the first argument, it will be used as the callback
   * function.
   *
   * @param { ConfigurationItemListInstanceEachOptions } [params] - Options for request
   * @param { function } [callback] - Function to process each record
   */
  each(callback?: (item: ConfigurationItemInstance, done: (err?: Error) => void) => void): void;
  each(params: ConfigurationItemListInstanceEachOptions, callback?: (item: ConfigurationItemInstance, done: (err?: Error) => void) => void): void;
  /**
   * Retrieve a single target page of ConfigurationItemInstance records from the API.
   *
   * The request is executed immediately.
   *
   * @param { string } [targetUrl] - API-generated URL for the requested results page
   * @param { function } [callback] - Callback to handle list of records
   */
  getPage(targetUrl: string, callback?: (error: Error | null, items: ConfigurationItemPage) => any): Promise<ConfigurationItemPage>;
  /**
   * Lists ConfigurationItemInstance records from the API as a list.
   *
   * If a function is passed as the first argument, it will be used as the callback
   * function.
   *
   * @param { ConfigurationItemListInstanceOptions } [params] - Options for request
   * @param { function } [callback] - Callback to handle list of records
   */
  list(callback?: (error: Error | null, items: ConfigurationItemInstance[]) => any): Promise<ConfigurationItemInstance[]>;
  list(params: ConfigurationItemListInstanceOptions, callback?: (error: Error | null, items: ConfigurationItemInstance[]) => any): Promise<ConfigurationItemInstance[]>;
  /**
   * Retrieve a single page of ConfigurationItemInstance records from the API.
   *
   * The request is executed immediately.
   *
   * If a function is passed as the first argument, it will be used as the callback
   * function.
   *
   * @param { ConfigurationItemListInstancePageOptions } [params] - Options for request
   * @param { function } [callback] - Callback to handle list of records
   */
  page(callback?: (error: Error | null, items: ConfigurationItemPage) => any): Promise<ConfigurationItemPage>;
  page(params: ConfigurationItemListInstancePageOptions, callback?: (error: Error | null, items: ConfigurationItemPage) => any): Promise<ConfigurationItemPage>;

  /**
   * Provide a user-friendly representation
   */
  toJSON(): any;
  [inspect.custom](_depth: any, options: InspectOptions): any;
}

export function ConfigurationItemListInstance(version: Authentix): ConfigurationItemListInstance {
  const instance = ((configurationId, ) => instance.get(configurationId, )) as ConfigurationItemListInstance;

  instance.get = function get(configurationId, ): ConfigurationItemContext {
    return new ConfigurationItemContextImpl(version, configurationId);
  }

  instance._version = version;
  instance._solution = {  };
  instance._uri = `/authentix/v1/configurations`;

  instance.create = function create(params: ConfigurationItemListInstanceCreateOptions, callback?: (error: Error | null, items: ConfigurationItemInstance) => any): Promise<ConfigurationItemInstance> {
    if (params === null || params === undefined) {
      throw new Error('Required parameter "params" missing.');
    }

    if (params["serviceName"] === null || params["serviceName"] === undefined) {
      throw new Error('Required parameter "params[\'serviceName\']" missing.');
    }

    let data: any = {};

    
        
    data["serviceName"] = params["serviceName"];
    if (params["codeLength"] !== undefined)
    data["codeLength"] = params["codeLength"];
    if (params["allowCustomCode"] !== undefined)
    data["allowCustomCode"] = serialize.bool(params["allowCustomCode"]);
    if (params["usedForDigitalPayment"] !== undefined)
    data["usedForDigitalPayment"] = serialize.bool(params["usedForDigitalPayment"]);
    if (params["defaultExpiryTime"] !== undefined)
    data["defaultExpiryTime"] = params["defaultExpiryTime"];
    if (params["defaultMaxTrials"] !== undefined)
    data["defaultMaxTrials"] = params["defaultMaxTrials"];
    if (params["defaultMaxControls"] !== undefined)
    data["defaultMaxControls"] = params["defaultMaxControls"];
    if (params["smtpSettingId"] !== undefined)
    data["smtpSettingId"] = params["smtpSettingId"];
    if (params["emailTemplateId"] !== undefined)
    data["emailTemplateId"] = params["emailTemplateId"];
    if (params["smsTemplateId"] !== undefined)
    data["smsTemplateId"] = params["smsTemplateId"];


    const headers: any = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded"

    let operationVersion = version,
        operationPromise = operationVersion.create({ uri: instance._uri, method: "post", data, headers });
    
    operationPromise = operationPromise.then(payload => new ConfigurationItemInstance(operationVersion, payload));
    

    operationPromise = instance._version.setPromiseCallback(operationPromise,callback);
    return operationPromise;


    }

  instance.page = function page(params?: ConfigurationItemListInstancePageOptions | ((error: Error | null, items: ConfigurationItemPage) => any), callback?: (error: Error | null, items: ConfigurationItemPage) => any): Promise<ConfigurationItemPage> {
    if (params instanceof Function) {
      callback = params;
      params = {};
    } else {
      params = params || {};
    }

    let data: any = {};

        if (params["pageSize"] !== undefined)
    data["pageSize"] = params["pageSize"];

    
    if (params.pageNumber !== undefined) data["page"] = params.pageNumber;

    const headers: any = {};

    let operationVersion = version,
        operationPromise = operationVersion.page({ uri: instance._uri, method: "get", params: data, headers });
    
    let basePageUrl = operationVersion.urlWithoutPaginationInfo(operationVersion.absoluteUrl(instance._uri), data);
    operationPromise = operationPromise.then(payload => new ConfigurationItemPage(basePageUrl, operationVersion, payload, instance._solution));

    operationPromise = instance._version.setPromiseCallback(operationPromise,callback);
    return operationPromise;

  }
  instance.each = instance._version.each;
  instance.list = instance._version.list;

  instance.getPage = function getPage(targetUrl: string, callback?: (error: Error | null, items: ConfigurationItemPage) => any): Promise<ConfigurationItemPage> {
    const operationPromise = instance._version._domain.reach.request({method: "get", uri: targetUrl});

    let basePageUrl = instance._version.urlWithoutPaginationInfo(targetUrl);
    let pagePromise = operationPromise.then(payload => new ConfigurationItemPage(basePageUrl, instance._version, payload, instance._solution));
    pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
    return pagePromise;
  }


  instance.toJSON = function toJSON() {
    return instance._solution;
  }

  instance[inspect.custom] = function inspectImpl(_depth: any, options: InspectOptions) {
    return inspect(instance.toJSON(), options);
  }

  return instance;
}

export class ConfigurationItemPage extends Page<Authentix, ConfigurationItemPayload, ConfigurationItemResource, ConfigurationItemInstance> {
/**
* Initialize the ConfigurationItemPage
*
* @param url - the url of the resource without pagination info
* @param version - Version of the resource
* @param response - Response from the API
* @param solution - Path solution
*/
constructor(url: string, version: Authentix, response: Response<string>, solution: ConfigurationItemSolution) {
    super(url, version, response, solution);
    }

    /**
    * Build an instance of ConfigurationItemInstance
    *
    * @param payload - Payload response from the API
    */
    getInstance(payload: ConfigurationItemResource): ConfigurationItemInstance {
    return new ConfigurationItemInstance(
    this._version,
    payload,
    );
    }

    [inspect.custom](depth: any, options: InspectOptions) {
    return inspect(this.toJSON(), options);
    }
    }

