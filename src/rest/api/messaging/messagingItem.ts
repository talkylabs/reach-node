/*
 * This code was generated by
 *  ___ ___   _   ___ _  _    _____ _   _    _  ___   ___      _   ___ ___      ___   _   ___     ___ ___ _  _ ___ ___    _ _____ ___  ___ 
 * | _ \ __| /_\ / __| || |__|_   _/_\ | |  | |/ | \ / / |    /_\ | _ ) __|___ / _ \ /_\ |_ _|__ / __| __| \| | __| _ \  /_\_   _/ _ \| _ \
 * |   / _| / _ \ (__| __ |___|| |/ _ \| |__| ' < \ V /| |__ / _ \| _ \__ \___| (_) / _ \ | |___| (_ | _|| .` | _||   / / _ \| || (_) |   /
 * |_|_\___/_/ \_\___|_||_|    |_/_/ \_\____|_|\_\ |_| |____/_/ \_\___/___/    \___/_/ \_\___|   \___|___|_|\_|___|_|_\/_/ \_\_| \___/|_|_\
 * 
 * Reach Messaging API
 * Reach SMS API helps you add robust messaging capabilities to your applications.  Using this REST API, you can * send SMS messages * track the delivery of sent messages * schedule SMS messages to send at a later time * retrieve and modify message history
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { inspect, InspectOptions } from "util";
import Page, { ReachResponsePayload } from "../../../base/Page";
import Response from "../../../http/response";
import Messaging from "../Messaging";
const deserialize = require("../../../base/deserialize");
const serialize = require("../../../base/serialize");
import { isValidPathParam } from "../../../base/utility";



/**
 * Options to pass to remove a MessagingItemInstance
 */
export interface MessagingItemContextRemoveOptions {
  /** The identifier of the message to be updated. */
  "messageId": string;
}

/**
 * Options to pass to fetch a MessagingItemInstance
 */
export interface MessagingItemContextFetchOptions {
  /** The identifier of the message to be updated. */
  "messageId": string;
}

/**
 * Options to pass to unschedule a MessagingItemInstance
 */
export interface MessagingItemContextUnscheduleOptions {
  /** The identifier of the message to be unscheduled. */
  "messageId": string;
}

/**
 * Options to pass to update a MessagingItemInstance
 */
export interface MessagingItemContextUpdateOptions {
  /** The identifier of the message to be updated. */
  "messageId": string;
  /** The text to be newly associated with the message. */
  "body": string;
}
/**
 * Options to pass to each
 */
export interface MessagingItemListInstanceEachOptions {
  /** Retrieve messages sent to only this phone number. The phone number in E.164 format of the message. */
  "dest"?: string;
  /** Retrieve messages sent from only this phone number, in E.164 format, or alphanumeric sender ID. */
  "src"?: string;
  /** Retrieve only messages that are assocaited with this `bulkIdentifier`. */
  "bulkIdentifier"?: string;
  /** Retrieve only messages sent at the specified date. Must be in ISO 8601 format. */
  "sentAt"?: Date;
  /** Retrieve only messages sent after the specified datetime. Must be in ISO 8601 format. */
  "sentAfter"?: Date;
  /** Retrieve only messages sent before the specified datetime. Must be in ISO 8601 format. */
  "sentBefore"?: Date;
  /** Maximum number of records to return per call. */
  "pageSize"?: number;
  /** Function to process each record. If this and a positional callback are passed, this one will be used */
  callback?: (item: MessagingItemInstance, done: (err?: Error) => void) => void;
  /** Function to be called upon completion of streaming */
  done?: Function;
  /** Upper limit for the number of records to return. each() guarantees never to return more than limit. Default is no limit */
  limit?: number;
}

/**
 * Options to pass to list
 */
export interface MessagingItemListInstanceOptions {
  /** Retrieve messages sent to only this phone number. The phone number in E.164 format of the message. */
  "dest"?: string;
  /** Retrieve messages sent from only this phone number, in E.164 format, or alphanumeric sender ID. */
  "src"?: string;
  /** Retrieve only messages that are assocaited with this `bulkIdentifier`. */
  "bulkIdentifier"?: string;
  /** Retrieve only messages sent at the specified date. Must be in ISO 8601 format. */
  "sentAt"?: Date;
  /** Retrieve only messages sent after the specified datetime. Must be in ISO 8601 format. */
  "sentAfter"?: Date;
  /** Retrieve only messages sent before the specified datetime. Must be in ISO 8601 format. */
  "sentBefore"?: Date;
  /** Maximum number of records to return per call. */
  "pageSize"?: number;
  /** Upper limit for the number of records to return. list() guarantees never to return more than limit. Default is no limit */
  limit?: number;
}

/**
 * Options to pass to page
 */
export interface MessagingItemListInstancePageOptions {
  /** Retrieve messages sent to only this phone number. The phone number in E.164 format of the message. */
  "dest"?: string;
  /** Retrieve messages sent from only this phone number, in E.164 format, or alphanumeric sender ID. */
  "src"?: string;
  /** Retrieve only messages that are assocaited with this `bulkIdentifier`. */
  "bulkIdentifier"?: string;
  /** Retrieve only messages sent at the specified date. Must be in ISO 8601 format. */
  "sentAt"?: Date;
  /** Retrieve only messages sent after the specified datetime. Must be in ISO 8601 format. */
  "sentAfter"?: Date;
  /** Retrieve only messages sent before the specified datetime. Must be in ISO 8601 format. */
  "sentBefore"?: Date;
  /** Maximum number of records to return per call. */
  "pageSize"?: number;
  /** Page Number, this value is simply for client state */
  pageNumber?: number;
}


/**
 * Options to pass to send a MessagingItemInstance
 */
export interface MessagingItemListInstanceSendOptions {
  /** The destination phone number in E.164 format of the message. */
  "dest": string;
  /** The phone number (in E.164 format), or the alphanumeric sender ID that initiated the message. */
  "src": string;
  /** The text of the message to send. It can be up to 1,600 GSM-7 characters in length. That limit varies if your message is not made of only GSM-7 characters. More generally, the message body should not exceed 10 segments. */
  "body": string;
  /** The identifier of the bulk operation this message belongs to. */
  "bulkIdentifier"?: string;
  /** The datetime at which the message will be sent. Must be in ISO 8601 format. A message must be scheduled at least 15 min in advance of message send time and cannot be scheduled more than 5 days in advance of the request. */
  "scheduledTime"?: Date;
  /** The URL that will be called to send status information of your message. If provided, the API POST these message status changes to the URL: `queued`, `failed`, `sent`, `canceled`, `delivered`, or `undelivered`. URLs must contain a valid hostname and underscores are not allowed.  */
  "statusCallback"?: string;
  /** The maximum total price in the applet currency that should be paid for the message to be delivered. If the cost exceeds `maxPrice`, the message will fail and a status of `failed` is sent to the status callback.  */
  "maxPrice"?: number;
  /** It represents how long, in seconds, the message can remain in the queue. After this period elapses, the message fails and the status callback is called. After a message has been accepted by a carrier, however, there is no guarantee that the message will not be queued after this period. It is recommended that this value be at least 5 seconds. The maximum allowed value is 14,400 which corresponds to 4 hours.  */
  "validityPeriod"?: number;
}

export interface MessagingItemContext {

  /**
   * Remove a MessagingItemInstance
   *
   * @param params - Parameter for request
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed MessagingItemInstance
   */
  remove(params: MessagingItemContextRemoveOptions, callback?: (error: Error | null, item?: boolean) => any): Promise<boolean>;

  /**
   * Fetch a MessagingItemInstance
   *
   * @param params - Parameter for request
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed MessagingItemInstance
   */
  fetch(params: MessagingItemContextFetchOptions, callback?: (error: Error | null, item?: MessagingItemInstance) => any): Promise<MessagingItemInstance>;

  /**
   * Unschedule a MessagingItemInstance
   *
   * @param params - Parameter for request
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed MessagingItemInstance
   */
  unschedule(params: MessagingItemContextUnscheduleOptions, callback?: (error: Error | null, item?: MessagingItemInstance) => any): Promise<MessagingItemInstance>;

  /**
   * Update a MessagingItemInstance
   *
   * @param params - Parameter for request
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed MessagingItemInstance
   */
  update(params: MessagingItemContextUpdateOptions, callback?: (error: Error | null, item?: MessagingItemInstance) => any): Promise<MessagingItemInstance>;



  /**
   * Provide a user-friendly representation
   */
  toJSON(): any;
  [inspect.custom](_depth: any, options: InspectOptions): any;
}

export interface MessagingItemContextSolution {
}

export class MessagingItemContextImpl implements MessagingItemContext {
  protected _solution: MessagingItemContextSolution;
  protected _uri: {[id: string]: string;};


  constructor(protected _version: Messaging) {
    this._solution = {  };
    this._uri = {};
    this._uri['fetch'] = `/messaging/v1/fetch`;
    this._uri['update'] = `/messaging/v1/update`;
    this._uri['unschedule'] = `/messaging/v1/unschedule`;
    this._uri['remove'] = `/messaging/v1/delete`;
  }

  remove(params: MessagingItemContextRemoveOptions, callback?: (error: Error | null, item?: boolean) => any): Promise<boolean> {
      if (params === null || params === undefined) {
      throw new Error('Required parameter "params" missing.');
    }

    if (params["messageId"] === null || params["messageId"] === undefined) {
      throw new Error('Required parameter "params[\'messageId\']" missing.');
    }

    let data: any = {};

        
    data["messageId"] = params["messageId"];

    

    const headers: any = {};

    const instance = this;
    let operationVersion = instance._version,
        operationPromise = operationVersion.remove({ uri: instance._uri['remove'], method: "delete", params: data, headers });
    

    operationPromise = instance._version.setPromiseCallback(operationPromise,callback);
    return operationPromise;


  }

  fetch(params: MessagingItemContextFetchOptions, callback?: (error: Error | null, item?: MessagingItemInstance) => any): Promise<MessagingItemInstance> {
      if (params === null || params === undefined) {
      throw new Error('Required parameter "params" missing.');
    }

    if (params["messageId"] === null || params["messageId"] === undefined) {
      throw new Error('Required parameter "params[\'messageId\']" missing.');
    }

    let data: any = {};

        
    data["messageId"] = params["messageId"];

    

    const headers: any = {};

    const instance = this;
    let operationVersion = instance._version,
        operationPromise = operationVersion.fetch({ uri: instance._uri['fetch'], method: "get", params: data, headers });
    
    operationPromise = operationPromise.then(payload => new MessagingItemInstance(operationVersion, payload));
    

    operationPromise = instance._version.setPromiseCallback(operationPromise,callback);
    return operationPromise;


  }

  unschedule(params: MessagingItemContextUnscheduleOptions, callback?: (error: Error | null, item?: MessagingItemInstance) => any): Promise<MessagingItemInstance> {
      if (params === null || params === undefined) {
      throw new Error('Required parameter "params" missing.');
    }

    if (params["messageId"] === null || params["messageId"] === undefined) {
      throw new Error('Required parameter "params[\'messageId\']" missing.');
    }

    let data: any = {};

    
        
    data["messageId"] = params["messageId"];


    const headers: any = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded"

    const instance = this;
    let operationVersion = instance._version,
        operationPromise = operationVersion.unschedule({ uri: instance._uri['unschedule'], method: "post", data, headers });
    
    operationPromise = operationPromise.then(payload => new MessagingItemInstance(operationVersion, payload));
    

    operationPromise = instance._version.setPromiseCallback(operationPromise,callback);
    return operationPromise;


  }

  update(params: MessagingItemContextUpdateOptions, callback?: (error: Error | null, item?: MessagingItemInstance) => any): Promise<MessagingItemInstance> {
      if (params === null || params === undefined) {
      throw new Error('Required parameter "params" missing.');
    }

    if (params["messageId"] === null || params["messageId"] === undefined) {
      throw new Error('Required parameter "params[\'messageId\']" missing.');
    }

    if (params["body"] === null || params["body"] === undefined) {
      throw new Error('Required parameter "params[\'body\']" missing.');
    }

    let data: any = {};

    
        
    data["messageId"] = params["messageId"];
    
    data["body"] = params["body"];


    const headers: any = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded"

    const instance = this;
    let operationVersion = instance._version,
        operationPromise = operationVersion.update({ uri: instance._uri['update'], method: "post", data, headers });
    
    operationPromise = operationPromise.then(payload => new MessagingItemInstance(operationVersion, payload));
    

    operationPromise = instance._version.setPromiseCallback(operationPromise,callback);
    return operationPromise;


  }

  /**
   * Provide a user-friendly representation
   *
   * @returns Object
   */
  toJSON() {
    return this._solution;
  }

  [inspect.custom](_depth: any, options: InspectOptions) {
    return inspect(this.toJSON(), options);
  }
}


interface MessagingItemPayload extends ReachResponsePayload {
    messages: MessagingItemResource[];
}

interface MessagingItemResource {
  appletId: string;
  apiVersion: string;
  body: string;
  dest: string;
  src: string;
  bulkId: string;
  numSegments: number;
  numMedia: number;
  price: number;
  priceUnit: string;
  messageId: string;
  status: string;
  messageType: string;
  errorCode: number;
  errorMessage: string;
  dateCreated: Date;
  dateSent: Date;
  dateUpdated: Date;
}

export class MessagingItemInstance {
  protected _solution: MessagingItemContextSolution;
  protected _context?: MessagingItemContext;

  constructor(protected _version: Messaging, payload: MessagingItemResource) {
    this.appletId = (payload.appletId);
    this.apiVersion = (payload.apiVersion);
    this.body = (payload.body);
    this.dest = (payload.dest);
    this.src = (payload.src);
    this.bulkId = (payload.bulkId);
    this.numSegments = deserialize.integer(payload.numSegments);
    this.numMedia = deserialize.integer(payload.numMedia);
    this.price = (payload.price);
    this.priceUnit = (payload.priceUnit);
    this.messageId = (payload.messageId);
    this.status = (payload.status);
    this.messageType = (payload.messageType);
    this.errorCode = deserialize.integer(payload.errorCode);
    this.errorMessage = (payload.errorMessage);
    this.dateCreated = deserialize.iso8601DateTime(payload.dateCreated);
    this.dateSent = deserialize.iso8601DateTime(payload.dateSent);
    this.dateUpdated = deserialize.iso8601DateTime(payload.dateUpdated);

    this._solution = {  };
  }

  /**
   * The identifier of the applet sending the message.
   */
  appletId: string;
  /**
   * The API version used to process the message.
   */
  apiVersion: string;
  /**
   * The message text.
   */
  body: string;
  /**
   * The phone number in E.164 format that received the message.
   */
  dest: string;
  /**
   * The phone number (in E.164 format), or the alphanumeric sender ID that initiated the message.
   */
  src: string;
  /**
   * The bulk identifier allowing to group messages together and have corresponding statistics.
   */
  bulkId: string;
  /**
   * The number of segments associated to the message. A message body that is too large to be sent in a single SMS is segmented and charged as multiple messages. The segments are reassembled once received by the destination phone. A message can have a maximum of 10 segments. 
   */
  numSegments: number;
  /**
   * The number of media files included in the message
   */
  numMedia: number;
  /**
   * The cost billed for the message, in the currency specified by `priceUnit`.
   */
  price: number;
  /**
   * The currency, in ISO 4127 format, in which price is measured. for example, usd, xaf, eur, cad.
   */
  priceUnit: string;
  /**
   * The identifier of the message
   */
  messageId: string;
  /**
   * The status of the message. Can be: `sent`, `scheduled`, `failed`, `delivered`, `undelivered`, `canceled`, `accepted`, `queued`, `sending`, `received`, `receiving`.  
   */
  status: string;
  /**
   * The type of the message. Can be: `inbound` for incoming messages, `outbound` for messages initiated by a REST API. 
   */
  messageType: string;
  /**
   * The error code returned if the message status is `failed` or `undelivered`. The errorMessage provides more information about the failure. The value is null if the message is successful. 
   */
  errorCode: number;
  /**
   * The error message returned if the message status is `failed` or `undelivered`.  The value is null if the message is successful. 
   */
  errorMessage: string;
  /**
   * The date and time in GMT that the message was created. 
   */
  dateCreated: Date;
  /**
   * The date and time in GMT that the message was sent. 
   */
  dateSent: Date;
  /**
   * The date and time in GMT that the message status was last updated. 
   */
  dateUpdated: Date;

  private get _proxy(): MessagingItemContext {
    this._context = this._context || new MessagingItemContextImpl(this._version);
    return this._context;
  }

  /**
   * Remove a MessagingItemInstance
   *
   * @param params - Parameter for request
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed MessagingItemInstance
   */
  remove(params: MessagingItemContextRemoveOptions, callback?: (error: Error | null, item?: boolean) => any): Promise<boolean>;

    remove(params?: any, callback?: (error: Error | null, item?: boolean) => any): Promise<boolean>
    {
    return this._proxy.remove(params, callback);
  }

  /**
   * Fetch a MessagingItemInstance
   *
   * @param params - Parameter for request
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed MessagingItemInstance
   */
  fetch(params: MessagingItemContextFetchOptions, callback?: (error: Error | null, item?: MessagingItemInstance) => any): Promise<MessagingItemInstance>;

    fetch(params?: any, callback?: (error: Error | null, item?: MessagingItemInstance) => any): Promise<MessagingItemInstance>
    {
    return this._proxy.fetch(params, callback);
  }

  /**
   * Unschedule a MessagingItemInstance
   *
   * @param params - Parameter for request
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed MessagingItemInstance
   */
  unschedule(params: MessagingItemContextUnscheduleOptions, callback?: (error: Error | null, item?: MessagingItemInstance) => any): Promise<MessagingItemInstance>;

    unschedule(params?: any, callback?: (error: Error | null, item?: MessagingItemInstance) => any): Promise<MessagingItemInstance>
    {
    return this._proxy.unschedule(params, callback);
  }

  /**
   * Update a MessagingItemInstance
   *
   * @param params - Parameter for request
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed MessagingItemInstance
   */
  update(params: MessagingItemContextUpdateOptions, callback?: (error: Error | null, item?: MessagingItemInstance) => any): Promise<MessagingItemInstance>;

    update(params?: any, callback?: (error: Error | null, item?: MessagingItemInstance) => any): Promise<MessagingItemInstance>
    {
    return this._proxy.update(params, callback);
  }

  /**
   * Provide a user-friendly representation
   *
   * @returns Object
   */
  toJSON() {
    return {
      appletId: this.appletId,
      apiVersion: this.apiVersion,
      body: this.body,
      dest: this.dest,
      src: this.src,
      bulkId: this.bulkId,
      numSegments: this.numSegments,
      numMedia: this.numMedia,
      price: this.price,
      priceUnit: this.priceUnit,
      messageId: this.messageId,
      status: this.status,
      messageType: this.messageType,
      errorCode: this.errorCode,
      errorMessage: this.errorMessage,
      dateCreated: this.dateCreated,
      dateSent: this.dateSent,
      dateUpdated: this.dateUpdated,
    }
  }

  [inspect.custom](_depth: any, options: InspectOptions) {
    return inspect(this.toJSON(), options);
  }
}


export interface MessagingItemSolution {
}

export interface MessagingItemListInstance {
  _version: Messaging;
  _solution: MessagingItemSolution;
  _uri: {[id: string]: string;};
  

  (): MessagingItemContext;
  get(): MessagingItemContext;











  /**
   * Streams MessagingItemInstance records from the API.
   *
   * This operation lazily loads records as efficiently as possible until the limit
   * is reached.
   *
   * The results are passed into the callback function, so this operation is memory
   * efficient.
   *
   * If a function is passed as the first argument, it will be used as the callback
   * function.
   *
   * @param { MessagingItemListInstanceEachOptions } [params] - Options for request
   * @param { function } [callback] - Function to process each record
   */
  each(callback?: (item: MessagingItemInstance, done: (err?: Error) => void) => void): void;
  each(params: MessagingItemListInstanceEachOptions, callback?: (item: MessagingItemInstance, done: (err?: Error) => void) => void): void;
  /**
   * Retrieve a single target page of MessagingItemInstance records from the API.
   *
   * The request is executed immediately.
   *
   * @param { string } [targetUrl] - API-generated URL for the requested results page
   * @param { function } [callback] - Callback to handle list of records
   */
  getPage(targetUrl: string, callback?: (error: Error | null, items: MessagingItemPage) => any): Promise<MessagingItemPage>;
  /**
   * Lists MessagingItemInstance records from the API as a list.
   *
   * If a function is passed as the first argument, it will be used as the callback
   * function.
   *
   * @param { MessagingItemListInstanceOptions } [params] - Options for request
   * @param { function } [callback] - Callback to handle list of records
   */
  list(callback?: (error: Error | null, items: MessagingItemInstance[]) => any): Promise<MessagingItemInstance[]>;
  list(params: MessagingItemListInstanceOptions, callback?: (error: Error | null, items: MessagingItemInstance[]) => any): Promise<MessagingItemInstance[]>;
  /**
   * Retrieve a single page of MessagingItemInstance records from the API.
   *
   * The request is executed immediately.
   *
   * If a function is passed as the first argument, it will be used as the callback
   * function.
   *
   * @param { MessagingItemListInstancePageOptions } [params] - Options for request
   * @param { function } [callback] - Callback to handle list of records
   */
  page(callback?: (error: Error | null, items: MessagingItemPage) => any): Promise<MessagingItemPage>;
  page(params: MessagingItemListInstancePageOptions, callback?: (error: Error | null, items: MessagingItemPage) => any): Promise<MessagingItemPage>;

  /**
   * Send a MessagingItemInstance
   *
   * @param params - Parameter for request
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed MessagingItemInstance
   */
  send(params: MessagingItemListInstanceSendOptions, callback?: (error: Error | null, item?: MessagingItemInstance) => any): Promise<MessagingItemInstance>;


  /**
   * Provide a user-friendly representation
   */
  toJSON(): any;
  [inspect.custom](_depth: any, options: InspectOptions): any;
}

export function MessagingItemListInstance(version: Messaging): MessagingItemListInstance {
  const instance = (() => instance.get()) as MessagingItemListInstance;

  instance.get = function get(): MessagingItemContext {
    return new MessagingItemContextImpl(version);
  }

  instance._version = version;
  instance._solution = {  };
  instance._uri = {};
  instance._uri['page'] = `/messaging/v1/list`;
  instance._uri['send'] = `/messaging/v1/create`;

  instance.page = function page(params?: MessagingItemListInstancePageOptions | ((error: Error | null, items: MessagingItemPage) => any), callback?: (error: Error | null, items: MessagingItemPage) => any): Promise<MessagingItemPage> {
    if (params instanceof Function) {
      callback = params;
      params = {};
    } else {
      params = params || {};
    }

    let data: any = {};

        if (params["dest"] !== undefined)
    data["dest"] = params["dest"];
    if (params["src"] !== undefined)
    data["src"] = params["src"];
    if (params["bulkIdentifier"] !== undefined)
    data["bulkIdentifier"] = params["bulkIdentifier"];
    if (params["sentAt"] !== undefined)
    data["sentAt"] = serialize.iso8601DateTime(params["sentAt"]);
    if (params["sentAfter"] !== undefined)
    data["sentAfter"] = serialize.iso8601DateTime(params["sentAfter"]);
    if (params["sentBefore"] !== undefined)
    data["sentBefore"] = serialize.iso8601DateTime(params["sentBefore"]);
    if (params["pageSize"] !== undefined)
    data["pageSize"] = params["pageSize"];

    
    if (params.pageNumber !== undefined) data["page"] = params.pageNumber;

    const headers: any = {};

    let operationVersion = version,
        operationPromise = operationVersion.page({ uri: instance._uri['page'], method: "get", params: data, headers });
    
    let basePageUrl = operationVersion.urlWithoutPaginationInfo(operationVersion.absoluteUrl(instance._uri['page']), data);
    operationPromise = operationPromise.then(payload => new MessagingItemPage(basePageUrl, operationVersion, payload, instance._solution));

    operationPromise = instance._version.setPromiseCallback(operationPromise,callback);
    return operationPromise;

  }
  instance.each = instance._version.each;
  instance.list = instance._version.list;

  instance.getPage = function getPage(targetUrl: string, callback?: (error: Error | null, items: MessagingItemPage) => any): Promise<MessagingItemPage> {
    const operationPromise = instance._version._domain.reach.request({method: "get", uri: targetUrl});

    let basePageUrl = instance._version.urlWithoutPaginationInfo(targetUrl);
    let pagePromise = operationPromise.then(payload => new MessagingItemPage(basePageUrl, instance._version, payload, instance._solution));
    pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
    return pagePromise;
  }


  instance.send = function send(params: MessagingItemListInstanceSendOptions, callback?: (error: Error | null, items: MessagingItemInstance) => any): Promise<MessagingItemInstance> {
    if (params === null || params === undefined) {
      throw new Error('Required parameter "params" missing.');
    }

    if (params["dest"] === null || params["dest"] === undefined) {
      throw new Error('Required parameter "params[\'dest\']" missing.');
    }

    if (params["src"] === null || params["src"] === undefined) {
      throw new Error('Required parameter "params[\'src\']" missing.');
    }

    if (params["body"] === null || params["body"] === undefined) {
      throw new Error('Required parameter "params[\'body\']" missing.');
    }

    let data: any = {};

    
        
    data["dest"] = params["dest"];
    
    data["src"] = params["src"];
    
    data["body"] = params["body"];
    if (params["bulkIdentifier"] !== undefined)
    data["bulkIdentifier"] = params["bulkIdentifier"];
    if (params["scheduledTime"] !== undefined)
    data["scheduledTime"] = serialize.iso8601DateTime(params["scheduledTime"]);
    if (params["statusCallback"] !== undefined)
    data["statusCallback"] = params["statusCallback"];
    if (params["maxPrice"] !== undefined)
    data["maxPrice"] = params["maxPrice"];
    if (params["validityPeriod"] !== undefined)
    data["validityPeriod"] = params["validityPeriod"];


    const headers: any = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded"

    let operationVersion = version,
        operationPromise = operationVersion.send({ uri: instance._uri['send'], method: "post", data, headers });
    
    operationPromise = operationPromise.then(payload => new MessagingItemInstance(operationVersion, payload));
    

    operationPromise = instance._version.setPromiseCallback(operationPromise,callback);
    return operationPromise;


    }

  instance.toJSON = function toJSON() {
    return instance._solution;
  }

  instance[inspect.custom] = function inspectImpl(_depth: any, options: InspectOptions) {
    return inspect(instance.toJSON(), options);
  }

  return instance;
}

export class MessagingItemPage extends Page<Messaging, MessagingItemPayload, MessagingItemResource, MessagingItemInstance> {
/**
* Initialize the MessagingItemPage
*
* @param url - the url of the resource without pagination info
* @param version - Version of the resource
* @param response - Response from the API
* @param solution - Path solution
*/
constructor(url: string, version: Messaging, response: Response<string>, solution: MessagingItemSolution) {
    super(url, version, response, solution);
    }

    /**
    * Build an instance of MessagingItemInstance
    *
    * @param payload - Payload response from the API
    */
    getInstance(payload: MessagingItemResource): MessagingItemInstance {
    return new MessagingItemInstance(
    this._version,
    payload,
    );
    }

    [inspect.custom](depth: any, options: InspectOptions) {
    return inspect(this.toJSON(), options);
    }
    }

